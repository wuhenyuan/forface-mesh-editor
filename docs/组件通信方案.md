# 组件通信方案

## 架构设计

```
┌─────────────────────────────────────────────────────┐
│                   EditorLayout                       │
│  ┌─────────────────────────────────────────────┐    │
│  │              editorStore (状态中心)           │    │
│  │  - currentFeature                            │    │
│  │  - menuVisible                               │    │
│  │  - textList                                  │    │
│  │  - undoStack / redoStack                     │    │
│  └─────────────────────────────────────────────┘    │
│         ↑              ↑              ↑              │
│    ┌────┴────┐   ┌────┴────┐   ┌────┴────┐         │
│    │ToolbarPanel│FeaturePanel│PropertyPanel│        │
│    └──────────┘ └──────────┘ └──────────┘          │
└─────────────────────────────────────────────────────┘
```

## 使用方式

### 1. 在组件中引入 store

```javascript
import { useEditorStore } from '@/store'

export default {
  setup() {
    const store = useEditorStore()
    
    // 读取状态（响应式）
    const currentFeature = computed(() => store.state.currentFeature)
    const menuVisible = computed(() => store.shouldShowMenu())
    
    // 调用方法
    const onFeatureChange = (feature) => {
      store.setFeature(feature)
    }
    
    return { currentFeature, menuVisible, onFeatureChange }
  }
}
```

### 2. 功能区切换示例

```javascript
// FeaturePanel.vue
const onSelect = (feature) => {
  store.setFeature(feature)
  // 自动处理：切换到非底座时隐藏菜单
}

// FeatureMenu.vue - 自动响应显隐
const visible = computed(() => store.shouldShowMenu())
```

### 3. 撤销重做示例

```javascript
// ToolbarPanel.vue
const handleUndo = () => {
  const action = store.undo()
  if (!action) return
  
  // 根据 action.type 执行具体撤销逻辑
  switch (action.type) {
    case 'TEXT_ADD':
      workspaceRef.value.deleteText(action.payload.textObject.id)
      break
    case 'TEXT_REMOVE':
      workspaceRef.value.restoreText(action.payload.removed)
      break
    case 'TEXT_UPDATE':
      workspaceRef.value.updateTextContent(
        action.payload.textId, 
        action.payload.from
      )
      break
  }
}
```

## 对比传统 props/emit

| 场景 | props/emit | store |
|------|-----------|-------|
| 控制菜单显隐 | 需要层层传递 | `store.setMenuVisible(false)` |
| 撤销重做 | 难以实现 | 内置 undoStack/redoStack |
| 跨组件通信 | 需要事件总线 | 直接读写 state |
| 状态追踪 | 分散各处 | 集中管理 |

## 优势

1. **无需 Vuex**：使用 Vue.observable，零依赖
2. **类型友好**：可轻松添加 TypeScript 支持
3. **调试方便**：状态集中，易于追踪
4. **解耦彻底**：组件间不再直接依赖
